// Generated by CoffeeScript 1.3.3
(function() {

  require(['components/require/require', 'components/decorate/decorate', 'components/Vector2d/Vector2d', 'components/mixin/lib/mixin', 'keyboard', 'Map', 'GameObject', 'DynamicGameObject', 'behaviors/Layer', 'behaviors/WallCollisions', 'behaviors/Gravity', 'behaviors/PlatformerWalker', 'behaviors/presenters/SlopeOnWalk', 'behaviors/controllers/PlatformerWalkerAI', 'behaviors/controllers/PlatformerKeyboard', 'behaviors/PlatformerJump', 'behaviors/CollisionCheck', 'behaviors/Moving', 'behaviors/Size', 'behaviors/Shooter', 'resources', 'settings', 'components/graphics/lib/layers/dom/DomRectLayer', 'GameObjectCollection', 'components/underscore/underscore'], function(require, decorate, Vector2d, mixin, keyboard, Map, GameObject, DynamicGameObject, Layer, WallCollisions, Gravity, PlatformerWalker, SlopeOnWalk, PlatformerWalkerAI, PlatformerKeyboardController, PlatformerJump, CollisionCheck, Moving, Size, Shooter, resources, settings, DomRectLayer, GameObjectCollection) {
    var createBox, createEnemy, deaths, enemies, gameLoop, intervalTime, kills, map, mapLayer, objDefaults, paused, player, points, unitDefaults, wallDefaults;
    kills = 0;
    deaths = 0;
    points = 0;
    paused = false;
    Gravity.g.setValues(0, settings.g);
    keyboard.init();
    mapLayer = new DomRectLayer({
      color: '#EEEEEE'
    });
    objDefaults = {
      size: settings.cellSize,
      cellSize: settings.cellSize,
      css: {
        outline: 'none'
      }
    };
    wallDefaults = _.defaults({
      parent: mapLayer
    }, objDefaults);
    map = new Map(resources.map1, resources.objDictionary, function(config, pos, map) {
      var cfg;
      cfg = _.extend({}, config, wallDefaults);
      cfg.pos = pos.substract(map.size.clone().divideScalar(2)).addScalar(0.5).multiply(settings.cellSize);
      return new DomRectLayer(cfg);
    });
    mapLayer.size.set(map.size.clone().multiply(settings.cellSize));
    mapLayer.redraw();
    unitDefaults = _.defaults({
      map: map
    }, objDefaults);
    Layer.defaults = {
      layerClass: DomRectLayer,
      layerConfig: objDefaults
    };
    enemies = new GameObjectCollection();
    player = new DynamicGameObject(_.defaults({
      behaviors: [PlatformerKeyboardController, PlatformerWalker, PlatformerJump, WallCollisions, Shooter, Gravity, SlopeOnWalk, Size, CollisionCheck],
      size: {
        x: 20,
        y: 20
      },
      checkCollision: {
        objects: enemies,
        handler: function(obj) {
          return this.die();
        }
      }
    }, unitDefaults));
    player.type = 'player';
    player.die = function() {
      $('#deathsVal').html(deaths);
      $('#gameover').show('slow');
      paused = true;
      return setTimeout((function() {
        var e, _i, _len, _ref;
        points = 0;
        $('#pointsVal').html(points);
        deaths++;
        $('#gameover').hide('slow');
        _ref = enemies.slice(0);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          e = _ref[_i];
          e.destructor();
        }
        player.pos.setValues(0, 0);
        paused = false;
        return createEnemy();
      }), 1000);
    };
    createBox = function() {
      var box, x, y;
      x = ~~(Math.random() * map.size.x);
      y = ~~(Math.random() * map.size.y);
      x -= map.size.x / 2;
      y -= map.size.x / 2;
      box = new DynamicGameObject(_.defaults({
        pos: new Vector2d(x, y).multiply(settings.cellSize),
        size: {
          x: 15,
          y: 15
        },
        layer: new DomRectLayer(_.defaults({
          color: 'green',
          size: {
            x: 15,
            y: 15
          },
          css: {
            zIndex: 9999,
            outline: 'none'
          }
        }, objDefaults)),
        behaviors: [Gravity, Layer, Size, Moving, WallCollisions]
      }, unitDefaults));
      box.config.checkCollision = {
        objects: [player],
        handler: function(obj) {
          points++;
          $('#pointsVal').html(points);
          return this.destructor();
        }
      };
      box.use(CollisionCheck);
      decorate(box, 'destructor', function() {
        return createBox();
      });
      return box;
    };
    window.createBox = createBox;
    player.createBullet = function(pos, direction) {
      var bullet;
      bullet = new DynamicGameObject({
        pos: this.pos,
        speed: direction,
        size: {
          x: 1,
          y: 1
        },
        layer: new DomRectLayer({
          color: 'orange',
          size: {
            x: 10,
            y: 2
          },
          css: {
            outline: 'none'
          }
        })
      });
      bullet.speed.multiplyScalar(20);
      bullet.speed.y = (Math.random() - 0.5) * 2;
      bullet.config.checkCollision = {
        objects: enemies,
        handler: function(obj) {
          kills++;
          $('#killsVal').html(kills);
          obj.destructor();
          return this.destructor();
        }
      };
      bullet.use(CollisionCheck);
      return bullet.use(Size);
    };
    createEnemy = function() {
      var enemySpawnPoint, unit;
      enemySpawnPoint = map.size.clone().multiply({
        x: 0,
        y: -0.5
      }).multiply(settings.cellSize);
      console.log(enemySpawnPoint);
      unit = new DynamicGameObject(_.extend({
        pos: enemySpawnPoint,
        walkSpeed: 0.5 + Math.random() * 3,
        layer: new DomRectLayer(_.extend({
          color: 'red'
        }, objDefaults)),
        behaviors: [PlatformerWalkerAI, PlatformerJump, WallCollisions, Gravity, Layer, Size]
      }, unitDefaults));
      enemies.push(unit);
      return unit;
    };
    mapLayer.redraw();
    intervalTime = 1000 / 60;
    gameLoop = function() {
      var unit, _i, _len, _ref, _results;
      if (paused) {
        return;
      }
      _ref = DynamicGameObject.collection;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        unit = _ref[_i];
        if (unit) {
          if ((Math.abs(unit.pos.y) > mapLayer.size.y / 2) || (Math.abs(unit.pos.x) > mapLayer.size.x / 2)) {
            if (unit.type === "player") {
              unit.die();
            } else {
              unit.destructor();
            }
          }
          unit.update();
          _results.push(unit.layer.redraw());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    setInterval(gameLoop, intervalTime);
    createEnemy();
    createBox();
    createEnemy();
    setInterval(function() {
      if (Math.random() < 0.44) {
        return createEnemy();
      }
    }, 500);
    window.objects = DynamicGameObject.collection;
    return window.enemies = enemies;
  });

}).call(this);
